Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4

====== Spring Web Reactive ======
**Youtube talks**
* [[https://www.youtube.com/watch?v=rdgJ8fOxJhc|Reactive Web Applications with Spring 5]]
* [[https://www.youtube.com/watch?v=Cj4foJzPF80|Developing Reactive applications with Reactive Streams and Java 8]]

**Resources**
* [[https://spring.io/blog/2016/04/19/understanding-reactive-types|Article spring]]
* [[http://techblog.netflix.com/2016/09/zuul-2-netflix-journey-to-asynchronous.html|Article Netflix de référence]]

===== Motivation et objectif =====
End of moore's now : only more cores, not faster ones !

Single threaded eventloop à la (node js) : New way to achieving scale
* never block (wait) the thread
* db call, api call → callback !

Reactive
* async 
* non blocking
* back pressure : ça sert à rien de fournir une donnée par call back si le client http qui doit l'utiliser derrière n'est pas prêt.

On peut faire des threads (asynchrones), mais qui bloquent. Il y a un coût associé à cela, que l'on désire supprimer. 

Callback : onNext, onComplete, onError

L'important, c'est pas seulement l'API, mais la facilité de composition avec une api fluent : nécessité d'operators : transform, timeouts,…

* **La latence côté producteur** est gérée à l'aide d'un retour immédiat à l'aide de Mono et de Flux (dans le cas de Reactor), avec même un Mono<Void>, void étant synchrone.
* **La latence côté consommateur** est traitée à l'aide d'un mécanisme de "Back pressure". Le consommateur notifie le producteur pour lui dire quand envoyer des éléments.

→ concurency : débug est difficile…

===== Par rapport à l'existant =====
* **Future<T>** introduit en java 5, c'est effectivement asynchrone MAIS pour obtenir la valeur, il faut faire un get qui lui est… bloquant ! Future n'est donc ni non-bloquant, ni un stream.
* **CompletableFuture<T>** introduit par java 8, il est asynchrone, non bloquant (mais pas un stream). Du coup, pour une liste on est obligé d'attendre la liste complète avant de pouvoir consommer le premier élément.
* **Stream<T>** introduit par java 8. Pas fait pour des données qui arrivent avec de la latence ! Dès qu'on a des I/O. pull style (bloquant)
* **InputStream / OutputStream** for streaming byte arrays. Bloquant. Certes, cervlet 3.1 permet un aspect non bloquant, mais c'est bien difficile à utiliser


===== Comparatif des implems =====
Très dur à implanter (pour la partie publisher); Il y a un TCK.

[[https://akarnokd.blogspot.fr/2016/03/operator-fusion-part-1.html|Très bon comparatif des implems]]

Regarder le tableau à 20 minutes !
* RxJava 1      : PAS de backpressure
* Akka Stream 2 : FULL reactive stream
* Reactor core 3: FULL reactive stream
* RxJava 2      : SEUL flowable est reactive, les autres ne le sont pas !

Qui choisir fin 2016 ?
* Reactor 3 avec Java 8+
* RxJava 2  avec Java 6+


===== Dans Spring 5 : Spring Web Reactive =====
Serveurs web suportés par spring réactive
* netty (serveur classique pour faire du non blocking)
* undertow
* jetty
* tomcat

Exemple de code à regarder la [[https://www.youtube.com/watch?v=Cj4foJzPF80|démo à partir de 1h23]] !
